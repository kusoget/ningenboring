<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Human Bowling 3D - Studio Lighting Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Helvetica Neue', Arial, sans-serif; }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
            z-index: 10;
        }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 20, 20, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 2000;
            text-align: center;
            padding: 20px;
            transition: opacity 0.5s ease;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .btn {
            margin-top: 20px;
            padding: 15px 35px;
            background: #00d4ff;
            color: black;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            pointer-events: auto;
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        input[type="file"] { display: none; }
    </style>
</head>
<body>

    <div id="overlay">
        <div id="loader-icon" class="spinner"></div>
        <h1 style="margin-bottom: 10px;">Human Bowling 3D</h1>
        <p id="status-text">
            高品質な3Dシーンを構築中...<br>
            <small>(3d/pin.glb と 3d/tama.glb が必要です)</small>
        </p>
        <div id="manual-upload" style="display:none">
            <p id="error-msg" style="color:#ff5555; margin-bottom:10px;"></p>
            <p>自動読み込みが制限されています。ファイルを選択してください。</p>
            <label class="btn" style="margin-bottom: 10px;">
                pin.glb (人間) を選択
                <input type="file" id="pin-upload" accept=".glb,.gltf">
            </label>
            <br>
            <label class="btn">
                tama.glb (球) を選択
                <input type="file" id="ball-upload" accept=".glb,.gltf">
            </label>
        </div>
    </div>

    <div id="ui" style="display:none">
        <div style="font-size: 1.8rem; font-weight: bold; color: #00d4ff;">CLICK TO SHOOT!</div>
        <div style="font-size: 1rem; opacity: 0.9; margin-top: 5px;">モデルが映えるスタジオライティング</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as CANNON from 'cannon-es';

        // パス設定
        const PIN_PATH = '3d/pin.glb';
        const BALL_PATH = '3d/tama.glb';

        // --- 物理エンジンの設定 ---
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
        
        const groundMaterial = new CANNON.Material('ground');
        const ballMaterial = new CANNON.Material('ball');
        const contactMaterial = new CANNON.ContactMaterial(groundMaterial, ballMaterial, {
            friction: 1.5,
            restitution: 0.2
        });
        world.addContactMaterial(contactMaterial);

        const physicsBodies = [];
        let activeBall = null;

        // --- Three.js の設定 ---
        const scene = new THREE.Scene();
        // 背景色を少し明るくしてスタジオ感を出す
        const bgColor = 0x333333;
        scene.background = new THREE.Color(bgColor);
        scene.fog = new THREE.Fog(bgColor, 30, 200);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const defaultCamPos = new THREE.Vector3(0, 10, 30);
        camera.position.copy(defaultCamPos);
        camera.lookAt(0, 0, -10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // --- 描画品質の向上 (ここが重要) ---
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // 映画のような発色
        renderer.toneMappingExposure = 1.2; // 露出を上げて明るくする
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- ライティングの再構築 ---
        // 1. 環境光 (全体を底上げ)
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        // 2. 半球ライト (空と地面からの反射光)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.8);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);

        // 3. メインライト (斜め上から強力に照らす)
        const mainLight = new THREE.DirectionalLight(0xffffff, 2.0);
        mainLight.position.set(20, 40, 30);
        mainLight.castShadow = true;
        mainLight.shadow.camera.left = -50;
        mainLight.shadow.camera.right = 50;
        mainLight.shadow.camera.top = 50;
        mainLight.shadow.camera.bottom = -50;
        mainLight.shadow.mapSize.set(2048, 2048);
        scene.add(mainLight);

        // 4. バックライト (モデルの輪郭を際立たせる)
        const backLight = new THREE.DirectionalLight(0x00d4ff, 1.0);
        backLight.position.set(-20, 20, -40);
        scene.add(backLight);

        // --- 床（レーン） ---
        const groundBody = new CANNON.Body({ 
            mass: 0, 
            shape: new CANNON.Plane(),
            material: groundMaterial
        });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        const groundMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 1000),
            new THREE.MeshStandardMaterial({ 
                color: 0x444444, 
                roughness: 0.1, 
                metalness: 0.5 
            })
        );
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // --- 管理変数とロード ---
        let pinModel = null;
        let ballModel = null;
        let isReady = false;

        const loader = new GLTFLoader();
        const overlay = document.getElementById('overlay');
        const statusText = document.getElementById('status-text');
        const manualUpload = document.getElementById('manual-upload');
        const errorMsg = document.getElementById('error-msg');
        const loaderIcon = document.getElementById('loader-icon');
        const uiLayer = document.getElementById('ui');

        function checkReady() {
            if (pinModel && ballModel) {
                initBowlingAlley();
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.style.display = 'none';
                    uiLayer.style.display = 'block';
                    isReady = true;
                }, 500);
            }
        }

        // ピンの配置
        function initBowlingAlley() {
            const spacing = 4.0;
            const startZ = -40;
            const positions = [
                { x: 0, z: startZ },
                { x: -spacing/2, z: startZ - spacing }, { x: spacing/2, z: startZ - spacing },
                { x: -spacing, z: startZ - spacing * 2 }, { x: 0, z: startZ - spacing * 2 }, { x: spacing, z: startZ - spacing * 2 },
                { x: -spacing*1.5, z: startZ - spacing * 3 }, { x: -spacing*0.5, z: startZ - spacing * 3 }, { x: spacing*0.5, z: startZ - spacing * 3 }, { x: spacing*1.5, z: startZ - spacing * 3 }
            ];

            positions.forEach((pos) => {
                const pinInstance = pinModel.clone();
                pinInstance.scale.set(2.2, 2.2, 2.2);
                pinInstance.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
                scene.add(pinInstance);

                const pinBody = new CANNON.Body({
                    mass: 8,
                    shape: new CANNON.Box(new CANNON.Vec3(1.1, 2.8, 0.6)),
                    material: new CANNON.Material({ friction: 0.4, restitution: 0.1 })
                });
                pinBody.position.set(pos.x, 2.8, pos.z);
                world.addBody(pinBody);
                physicsBodies.push({ mesh: pinInstance, body: pinBody });
            });
        }

        // --- モデルのセンタリングと正規化 ---
        function processBallModel(sceneGroup) {
            const box = new THREE.Box3().setFromObject(sceneGroup);
            const center = new THREE.Vector3();
            box.getCenter(center);
            sceneGroup.position.sub(center); 

            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const scaleFactor = (1.5 * 2) / maxDim;
            
            const wrapper = new THREE.Group();
            wrapper.add(sceneGroup);
            wrapper.scale.set(scaleFactor, scaleFactor, scaleFactor);
            return wrapper;
        }

        function resolvePath(path) {
            if (window.location.protocol === 'blob:') return path;
            try {
                return new URL(path, window.location.href).href;
            } catch (e) {
                return path;
            }
        }

        function loadAssets() {
            if (window.location.protocol === 'blob:') {
                showManualUpload("環境制限により自動読み込みができません。ファイルを選択してください。");
                return;
            }

            const pinUrl = resolvePath(PIN_PATH);
            const ballUrl = resolvePath(BALL_PATH);

            loader.load(pinUrl, (gltf) => {
                pinModel = gltf.scene;
                checkReady();
            }, undefined, (err) => {
                showManualUpload("ピンの読み込みに失敗しました。");
            });

            loader.load(ballUrl, (gltf) => {
                ballModel = processBallModel(gltf.scene);
                checkReady();
            }, undefined, (err) => {
                showManualUpload("ボールの読み込みに失敗しました。");
            });
        }

        function showManualUpload(msg) {
            manualUpload.style.display = 'block';
            loaderIcon.style.display = 'none';
            errorMsg.innerText = msg;
        }

        loadAssets();

        // 手動ファイル選択
        document.getElementById('pin-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loader.load(URL.createObjectURL(file), (gltf) => {
                    pinModel = gltf.scene;
                    checkReady();
                });
            }
        });

        document.getElementById('ball-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loader.load(URL.createObjectURL(file), (gltf) => {
                    ballModel = processBallModel(gltf.scene);
                    checkReady();
                });
            }
        });

        // --- ボール発射 ---
        const shoot = () => {
            if (!isReady || !ballModel) return;
            
            const ballRadius = 1.5;
            const ballMesh = ballModel.clone();
            ballMesh.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
            scene.add(ballMesh);

            const ballBody = new CANNON.Body({
                mass: 250, 
                shape: new CANNON.Sphere(ballRadius),
                material: ballMaterial,
                linearDamping: 0.05,
                angularDamping: 0.05
            });
            
            ballBody.position.set((Math.random() - 0.5) * 4, ballRadius, 30);
            const power = 22; 
            ballBody.velocity.set(0, 0, -power);
            ballBody.angularVelocity.set(-10, 0, 0); 
            
            world.addBody(ballBody);
            
            const ballObj = { mesh: ballMesh, body: ballBody };
            physicsBodies.push(ballObj);
            activeBall = ballObj; 
        };

        window.addEventListener('mousedown', shoot);

        // --- 更新ループ ---
        const fixedTimeStep = 1 / 60;
        function animate() {
            requestAnimationFrame(animate);
            world.fixedStep();
            
            physicsBodies.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });

            if (activeBall) {
                const bPos = activeBall.mesh.position;
                const targetCamPos = new THREE.Vector3(bPos.x * 0.7, bPos.y + 10, bPos.z + 25);
                camera.position.lerp(targetCamPos, 0.05);
                camera.lookAt(bPos.x, bPos.y, bPos.z - 15);
                
                if (bPos.z < -150) { activeBall = null; }
            } else {
                camera.position.lerp(defaultCamPos, 0.02);
                camera.lookAt(0, 0, -10);
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
